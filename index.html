<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mirra Buddy - Diagram Builder</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; background-color: #f0f2f5; }
        #page-header { background-color: #004085; color: white; padding: 12px 20px; text-align: center; box-shadow: 0 2px 5px rgba(0,0,0,0.25); z-index: 30; }
        #page-header h1 { margin: 0; font-size: 1.4em; font-weight: 500; }
        #app-container { display: flex; flex-grow: 1; overflow: hidden; }
        #sidebar { width: 250px; background-color: #f4f4f4; border-right: 1px solid #ddd; padding: 15px; overflow-y: auto; box-shadow: 2px 0 5px rgba(0,0,0,0.1); position: relative; z-index: 20; }
        #sidebar h3 { margin-top: 0; color: #333; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-bottom: 15px; }
        .tool-item { padding: 10px; margin-bottom: 8px; background-color: #fff; border: 1px solid #eee; border-radius: 4px; cursor: grab; font-size: 0.9em; display: flex; align-items: center; gap: 10px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .tool-item:hover { background-color: #e9e9e9; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .tool-item.dragging { opacity: 0.5; border-style: dashed; }
        #main-content { flex-grow: 1; display: flex; flex-direction: column; }
        #toolbar {
            height: 50px;
            background-color: #e0e0e0;
            border-bottom: 1px solid #ccc;
            display: flex;
            align-items: center;
            padding: 0 15px;
            gap: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 15;
            flex-shrink: 0;
            flex-wrap: nowrap;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toolbar-group.text-tools {
            margin-left: auto;
            gap: 2px;
        }

        .toolbar-button { padding: 8px 12px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s, transform 0.1s; }
        .toolbar-button:hover:not(:disabled) { background-color: #0056b3; transform: translateY(-1px); }
        .toolbar-button.active { background-color: #28a745; }
        #removeNodeBtn { background-color: #c82333; }
        #removeNodeBtn:hover:not(:disabled) { background-color: #a71d2a; }
        .toolbar-button:disabled { background-color: #e9ecef; color: #6c757d; cursor: not-allowed; opacity: 0.65; transform: none; }
        .toolbar-input, .toolbar-select { padding: 6px; border: 1px solid #ccc; border-radius: 4px; width: auto; }
        .toolbar-input:disabled, .toolbar-select:disabled { background-color: #e9ecef; cursor: not-allowed; }
        #nodeColorInput {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 35px;
            height: 25px;
            background-color: transparent;
            border: 1px solid #ccc;
            cursor: pointer;
            padding: 0;
        }
        #nodeColorInput::-webkit-color-swatch { border: none; border-radius: 4px; }
        #nodeColorInput::-moz-color-swatch { border: none; border-radius: 4px; }
        
        #canvas-container { flex-grow: 1; background-color: #f9f9f9; position: relative; overflow: auto; border: 1px solid #ddd; margin: 15px; border-radius: 8px; box-shadow: inset 0 0 10px rgba(0,0,0,0.05); }
        #workflow-canvas { min-width: 2000px; min-height: 1500px; background-image: linear-gradient(to right, #eee 1px, transparent 1px), linear-gradient(to bottom, #eee 1px, transparent 1px); background-size: 20px 20px; position: absolute; width: 100%; height: 100%; }
        .workflow-node, .text-box { position: absolute; background-color: #fff; border: 1px solid #aaa; border-radius: 8px; padding: 15px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); min-width: 120px; min-height: 60px; display: flex; align-items: center; justify-content: center; cursor: grab; transition: border-color 0.2s, background-color 0.2s, box-shadow 0.2s; z-index: 10; box-sizing: border-box; overflow: hidden; }
        .text-box { min-width: 100px; min-height: 30px; padding: 10px; background-color: #fdfdff; border: 1px dashed #bbb; box-shadow: 0 2px 5px rgba(0,0,0,0.05); font-size: 1em; text-align: left; align-items: flex-start; justify-content: flex-start; }
        .workflow-node-text { word-break: break-word; }
        .workflow-node[data-type="circle"] { border-radius: 50%; min-width: 100px; min-height: 100px; padding: 10px; }
        .workflow-node[data-type="end"] { background-color: #dc3545; color: white; clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%); border-radius: 0; border: none; }
        .workflow-node[data-type="diamond"] { border-radius: 0; border: none; background-color: transparent; padding: 0; min-width: 120px; min-height: 60px; box-shadow: none; overflow: visible; display: flex; align-items: center; justify-content: center; }
        .workflow-node[data-type="diamond"] > .rhombus-shape { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #fff; border: none; clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); display: flex; align-items: center; justify-content: center; box-sizing: border-box; box-shadow: 0 4px 8px rgba(0,0,0,0.1); overflow: hidden; transition: background-color 0.2s; }
        .workflow-node[data-type="diamond"] .workflow-node-text { transform: none; max-width: 90%; padding: 5px 10px; text-align: center; z-index: 1; }
        .workflow-node[data-type="parallelogram"] { transform: skewX(-20deg); }
        .workflow-node[data-type="parallelogram"] .workflow-node-text { transform: skewX(20deg); }
        .workflow-node.selected:not([data-type="diamond"]):not([data-type="end"]), .text-box.selected { border-color: #007bff; box-shadow: 0 4px 12px rgba(0,123,255,0.2); }
        .workflow-node[data-type="end"].selected { box-shadow: 0 0 0 3px #007bff, 0 4px 12px rgba(0,123,255,0.3); }
        .workflow-node[data-type="diamond"].selected { border: 1px solid #007bff; box-shadow: 0 4px 12px rgba(0,123,255,0.2); border-radius: 8px; }
        .workflow-node[data-type="diamond"].selected > .rhombus-shape { box-shadow: none; }

        .connection-line { position: absolute; z-index: 5; pointer-events: auto; }
        .connection-line.straight { height: 0; border-bottom-width: 2px; border-bottom-color: #555; transform-origin: 0 0; }
        .connection-line.straight[data-style="solid"] { border-bottom-style: solid; }
        .connection-line.straight[data-style="dotted"] { border-bottom-style: dotted; }
        .connection-line.straight.selected { border-bottom-color: #007bff; border-bottom-width: 3px; }
        .connection-line.orthogonal .line-segment { position: absolute; background-color: #555; width: 2px; height: 2px; }
        .connection-line.orthogonal .line-segment.solid { background-color: #555; }
        .connection-line.orthogonal .line-segment.dotted { background-color: transparent; border: none; outline: 2px dotted #555; outline-offset: -1px; box-sizing: border-box; }
        .connection-line.orthogonal .line-segment.selected { background-color: #007bff; outline-color: #007bff; }
        .connection-line.orthogonal .line-segment.selected.dotted { outline: 3px dotted #007bff; outline-offset: -1.5px; }
        .workflow-node.line-selected { outline: 2px solid #28a745; outline-offset: 2px; box-shadow: 0 0 15px rgba(40, 167, 69, 0.5); }

        #text-formatting-toolbar { display: flex; gap: 2px; border: 1px solid #ccc; border-radius: 4px; padding: 2px; background-color: #f0f0f0; opacity: 1; transition: opacity 0.2s ease-in-out; align-items: center; }
        #text-formatting-toolbar.disabled { opacity: 0.5; pointer-events: none; }
        .text-format-button { background-color: #e0e0e0; color: #333; border: 1px solid #bbb; border-radius: 3px; padding: 4px 8px; cursor: pointer; font-size: 0.8em; font-weight: bold; min-width: 28px; text-align: center; transition: background-color 0.1s; line-height: 1; display: flex; justify-content: center; align-items: center; }
        .text-format-button:hover:not(:disabled) { background-color: #d0d0d0; }
        .text-format-button.active { background-color: #007bff; color: white; border-color: #0056b3; }
        .text-format-button.disabled { background-color: #f8f8f8; color: #999; border-color: #ddd; cursor: not-allowed; }
        .text-format-button.align-icon { font-size: 1.2em; padding: 4px 6px; font-weight: normal; }
        .text-format-button.align-icon[data-command="justifyLeft"]::before { content: '\2630'; text-align: left; width: 100%; display: block; }
        .text-format-button.align-icon[data-command="justifyCenter"]::before { content: '\2630'; text-align: center; width: 100%; display: block; }
        .text-format-button.align-icon[data-command="justifyRight"]::before { content: '\2630'; text-align: right; width: 100%; display: block; }

        .toolbar-group-separator { width: 1px; background-color: #ccc; height: 30px; margin: 0 15px; }
        .toolbar-line-separator { width: 1px; background-color: #ccc; height: 20px; margin: 0 5px; }
        .toolbar-group label { margin-left: 0; margin-right: 5px; white-space: nowrap; }
        .toolbar-group .toolbar-input, .toolbar-group .toolbar-select { margin-right: 0; }
        #text-formatting-toolbar label[for="fontSizeInput"] { margin-right: 5px; }
        #text-formatting-toolbar input#fontSizeInput { margin-right: 0; }

        #shortcuts-legend { margin-top: 20px; }
        #shortcuts-legend h3 { margin-bottom: 10px; }
        #shortcuts-legend ul { list-style: none; padding: 0; margin: 0; font-size: 0.9em; color: #333; }
        #shortcuts-legend li { display: flex; align-items: center; gap: 5px; padding: 8px 0; border-bottom: 1px solid #e9e9e9; }
        #shortcuts-legend li:last-child { border-bottom: none; }
        #shortcuts-legend kbd { font-family: 'Consolas', 'Menlo', monospace; padding: 2px 6px; border-radius: 3px; background-color: #e0e0e0; border: 1px solid #ccc; box-shadow: 1px 1px 1px rgba(0,0,0,0.1); font-size: 0.9em; }
        #shortcuts-legend span { margin-left: auto; text-align: right; color: #555; }
        @media print { body > *:not(.print-window-container) { display: none !important; } }
    </style>
</head>
<body>
    <header id="page-header"> <h1>Mirra Buddy - Diagram Builder</h1> </header>
    <div id="app-container">
        <div id="sidebar">
            <h3>Toolbox</h3>
            <div class="tool-item" draggable="true" data-type="start">➡️ Start Node</div>
            <div class="tool-item" draggable="true" data-type="process">⚙️ Process Step</div>
            <div class="tool-item" draggable="true" data-type="decision">🤔 Decision</div>
            <div class="tool-item" draggable="true" data-type="end">🛑 End Node</div>
            <hr><h3>Shapes</h3>
            <div class="tool-item" draggable="true" data-type="rectangle">⬛ Rectangle</div>
            <div class="tool-item" draggable="true" data-type="circle">🔵 Circle</div>
            <div class="tool-item" draggable="true" data-type="diamond">◇ Rhombus</div>
            <div class="tool-item" draggable="true" data-type="parallelogram">▰ Parallelogram</div>
            <hr><h3>Content</h3>
            <div class="tool-item" draggable="true" data-type="text-box">📄 Text Box</div>

            <div id="shortcuts-legend">
                <hr><h3>Shortcuts</h3>
                <ul>
                    <li><kbd>Ctrl</kbd> + <kbd>Click</kbd><span>Multi-select / Resize Node</span></li>
                    <li><kbd>Ctrl</kbd> + <kbd>C</kbd><span>Copy Node</span></li>
                    <li><kbd>Ctrl</kbd> + <kbd>V</kbd><span>Paste Node</span></li>
                    <li><kbd>Ctrl</kbd> + <kbd>Z</kbd><span>Undo Action</span></li>
                    <li><kbd>Ctrl</kbd> + <kbd>Y</kbd><span>Redo Action</span></li>
                    <li><kbd>Del / Backspace</kbd><span>Delete Element</span></li>
                </ul>
            </div>
        </div>
        <div id="main-content">
            <div id="toolbar">
                <div class="toolbar-group">
                    <button class="toolbar-button" id="saveBtn">Save</button>
                    <button class="toolbar-button" id="loadBtn">Load</button>
                    <button class="toolbar-button" id="exportPdfBtn">Export to PDF</button>
                    <button class="toolbar-button" id="exportJsonBtn">Export JSON</button>
                    <button class="toolbar-button" id="importBtn">Import JSON</button>
                    <button class="toolbar-button" id="printBtn">Print</button>
                </div>
                <div class="toolbar-group-separator"></div>
                <div class="toolbar-group">
                    <button class="toolbar-button" id="clearCanvasBtn">Clear Canvas</button>
                    <button class="toolbar-button" id="removeNodeBtn" disabled>Remove</button>
                </div>
                <div class="toolbar-group-separator"></div>
                <div class="toolbar-group">
                    <button class="toolbar-button" id="connectNodesBtn">Connect Nodes</button>
                    <label for="lineStyleSelect">Line:</label>
                    <select id="lineStyleSelect" class="toolbar-select">
                        <option value="solid">Solid</option>
                        <option value="dotted">Dotted</option>
                        <option value="orthogonal">Orthogonal</option>
                    </select>
                    <div class="toolbar-line-separator"></div>
                    <label for="nodeColorInput">Color:</label>
                    <input type="color" id="nodeColorInput" class="toolbar-input" value="#ffffff" disabled>
                    <div class="toolbar-line-separator"></div>
                    <label for="gridSizeInput">Grid:</label>
                    <input type="number" id="gridSizeInput" class="toolbar-input" min="5" max="50" value="20" style="width: 50px;">
                </div>
                <div class="toolbar-group text-tools">
                    <div id="text-formatting-toolbar" class="disabled">
                        <label for="fontSizeInput">Font Size:</label>
                        <input type="number" id="fontSizeInput" class="toolbar-input" min="8" max="72" value="14" disabled>
                        <div class="toolbar-line-separator"></div>
                        <button class="text-format-button" data-command="bold">B</button>
                        <button class="text-format-button" data-command="italic">I</button>
                        <button class="text-format-button" data-command="underline">U</button>
                        <div class="toolbar-line-separator"></div>
                        <button class="text-format-button align-icon" data-command="justifyLeft"></button>
                        <button class="text-format-button align-icon" data-command="justifyCenter"></button>
                        <button class="text-format-button align-icon" data-command="justifyRight"></button>
                    </div>
                </div>
            </div>
            <div id="canvas-container"> <div id="workflow-canvas"></div> </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script>
        const workflowCanvas = document.getElementById('workflow-canvas');
        const connectNodesBtn = document.getElementById('connectNodesBtn');
        const fontSizeInput = document.getElementById('fontSizeInput');
        const removeNodeBtn = document.getElementById('removeNodeBtn');
        const lineStyleSelect = document.getElementById('lineStyleSelect');
        const gridSizeInput = document.getElementById('gridSizeInput');
        const textFormattingToolbar = document.getElementById('text-formatting-toolbar');
        const nodeColorInput = document.getElementById('nodeColorInput');

        const state = {
            draggedItem: null, isConnectingMode: false, firstNodeForConnection: null,
            selectedNodes: new Set(), selectedLine: null, isResizing: false,
            resizingElement: null, resizeStartX: 0, resizeStartY: 0,
            initialWidth: 0, initialHeight: 0, connections: [], history: [],
            historyIndex: -1, clipboard: null, gridSize: parseInt(gridSizeInput.value, 10),
            dragOffsets: new Map()
        };

        function generateUniqueId(prefix) { return `${prefix}-${Date.now()}-${Math.floor(Math.random() * 1000)}`; }
        function getElementCenter(el) { return { x: el.offsetLeft + el.offsetWidth / 2, y: el.offsetTop + el.offsetHeight / 2 }; }
        function getTextElement(node) {
            if (!node) return null;
            if (node.dataset.type === 'diamond') return node.querySelector('.rhombus-shape .workflow-node-text');
            return node.querySelector('.workflow-node-text');
        }
        function rgbToHex(rgbStr) {
            if (!rgbStr || !rgbStr.includes('rgb')) return '#ffffff';
            const match = rgbStr.match(/rgba?\((\d{1,3}), (\d{1,3}), (\d{1,3})/);
            if (!match) return '#ffffff';
            const r = parseInt(match[1], 10);
            const g = parseInt(match[2], 10);
            const b = parseInt(match[3], 10);
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        function saveStateToHistory() {
            const currentState = { nodes: [], connections: [] };
            document.querySelectorAll('.workflow-node, .text-box').forEach(node => {
                const textElement = getTextElement(node);
                const colorTarget = node.dataset.type === 'diamond' ? node.querySelector('.rhombus-shape') : node;
                currentState.nodes.push({
                    id: node.id, type: node.dataset.type, text: textElement ? textElement.innerHTML : '',
                    left: node.style.left, top: node.style.top, width: node.style.width, height: node.style.height,
                    fontSize: textElement ? textElement.style.fontSize : '',
                    backgroundColor: colorTarget ? colorTarget.style.backgroundColor : ''
                });
            });
            state.connections.forEach(conn => currentState.connections.push({ id: conn.id, startNodeId: conn.startNodeId, endNodeId: conn.endNodeId, style: conn.style, lineRoute: conn.lineRoute }));
            if (JSON.stringify(state.history[state.historyIndex]) === JSON.stringify(currentState)) return;
            state.history = state.history.slice(0, state.historyIndex + 1); state.history.push(currentState);
            if (state.history.length > 50) state.history.shift();
            state.historyIndex = state.history.length - 1;
        }
        function loadStateFromHistory(index) { if (index < 0 || index >= state.history.length) return; state.historyIndex = index; loadWorkflowDataIntoCanvas(state.history[index], false); }

        document.querySelectorAll('.tool-item').forEach(item => {
            item.addEventListener('dragstart', (e) => { state.draggedItem = e.target; e.dataTransfer.effectAllowed = 'copy'; e.dataTransfer.setData('text/plain', e.target.dataset.type); setTimeout(() => e.target.classList.add('dragging'), 0); });
            item.addEventListener('dragend', (e) => e.target.classList.remove('dragging'));
        });
        workflowCanvas.addEventListener('dragover', (e) => e.preventDefault());
        workflowCanvas.addEventListener('drop', (e) => { e.preventDefault(); if (!state.draggedItem) return; createNodeOnCanvas(e.dataTransfer.getData('text/plain'), e.clientX, e.clientY); state.draggedItem = null; });

        function createNodeOnCanvas(type, clientX, clientY, nodeData = {}) {
            let newElement, textContentDiv;
            const isPastingOrLoading = Object.keys(nodeData).length > 0;
            if (type === 'text-box') { newElement = document.createElement('div'); newElement.className = 'text-box';
            } else if (type === 'diamond') {
                newElement = document.createElement('div'); newElement.className = 'workflow-node'; const rhombusShape = document.createElement('div'); rhombusShape.className = 'rhombus-shape'; newElement.appendChild(rhombusShape); textContentDiv = document.createElement('div'); textContentDiv.className = 'workflow-node-text'; rhombusShape.appendChild(textContentDiv);
            } else { newElement = document.createElement('div'); newElement.className = 'workflow-node'; }
            if (!textContentDiv) { textContentDiv = document.createElement('div'); textContentDiv.className = 'workflow-node-text'; newElement.appendChild(textContentDiv); }
            newElement.id = nodeData.id || generateUniqueId(type); newElement.dataset.type = type;
            textContentDiv.setAttribute('contenteditable', 'true');
            textContentDiv.innerHTML = nodeData.text || `${type.charAt(0).toUpperCase() + type.slice(1)} Node`;
            if (nodeData.fontSize) textContentDiv.style.fontSize = nodeData.fontSize;
            if (nodeData.backgroundColor) {
                const colorTarget = newElement.dataset.type === 'diamond' ? newElement.querySelector('.rhombus-shape') : newElement;
                if(colorTarget) colorTarget.style.backgroundColor = nodeData.backgroundColor;
            }
            workflowCanvas.appendChild(newElement);
            let dropX, dropY;
            if (isPastingOrLoading) { dropX = parseFloat(nodeData.left); dropY = parseFloat(nodeData.top);
            } else {
                const canvasRect = workflowCanvas.getBoundingClientRect();
                dropX = clientX - canvasRect.left + workflowCanvas.scrollLeft;
                dropY = clientY - canvasRect.top + workflowCanvas.scrollTop;
            }
            const snappedX = Math.round((dropX - newElement.offsetWidth / 2) / state.gridSize) * state.gridSize;
            const snappedY = Math.round((dropY - newElement.offsetHeight / 2) / state.gridSize) * state.gridSize;
            newElement.style.left = `${snappedX}px`; newElement.style.top = `${snappedY}px`;
            newElement.style.width = nodeData.width || ''; newElement.style.height = nodeData.height || '';
            addTextEditingListeners(textContentDiv);
            if (!isPastingOrLoading) saveStateToHistory();
            return newElement;
        }
        
        workflowCanvas.addEventListener('mousedown', (e) => {
            const isTextClick = e.target.classList.contains('workflow-node-text') && !e.ctrlKey && !e.metaKey
            if (isTextClick && e.target.contentEditable === 'true') return;
            const clickedNode = e.target.closest('.workflow-node, .text-box');
            const clickedLineElement = e.target.closest('.connection-line');
            const isCtrlCmd = e.ctrlKey || e.metaKey;
            if (state.isConnectingMode) { if (clickedNode) handleNodeConnectionClick(clickedNode); return; }
            if (clickedLineElement) { selectLine(clickedLineElement); return; }
            if (clickedNode) {
                if (isCtrlCmd) { state.selectedNodes.has(clickedNode) ? deselectNode(clickedNode) : selectNode(clickedNode);
                } else { if (!state.selectedNodes.has(clickedNode)) { deselectAllElements(); selectNode(clickedNode); } }
                if (isCtrlCmd && state.selectedNodes.size === 1) {
                    state.isResizing = true; state.resizingElement = clickedNode; state.initialWidth = clickedNode.offsetWidth;
                    state.initialHeight = clickedNode.offsetHeight; state.resizeStartX = e.clientX; state.resizeStartY = e.clientY;
                    document.body.style.cursor = 'nwse-resize';
                } else if (state.selectedNodes.has(clickedNode)) {
                    state.dragOffsets.clear();
                    state.selectedNodes.forEach(node => {
                        state.dragOffsets.set(node, { x: node.offsetLeft - e.clientX, y: node.offsetTop - e.clientY });
                        node.style.cursor = 'grabbing';
                    });
                    function onElementMouseMove(moveEvent) {
                        state.selectedNodes.forEach(node => {
                            const offset = state.dragOffsets.get(node);
                            node.style.left = `${Math.round((moveEvent.clientX + offset.x) / state.gridSize) * state.gridSize}px`;
                            node.style.top = `${Math.round((moveEvent.clientY + offset.y) / state.gridSize) * state.gridSize}px`;
                            updateElementConnections(node);
                        });
                    }
                    function onElementMouseUp(upEvent) {
                        state.selectedNodes.forEach(node => node.style.cursor = 'grab');
                        if (e.clientX !== upEvent.clientX || e.clientY !== upEvent.clientY) saveStateToHistory();
                        window.removeEventListener('mousemove', onElementMouseMove);
                        window.removeEventListener('mouseup', onElementMouseUp);
                    }
                    window.addEventListener('mousemove', onElementMouseMove);
                    window.addEventListener('mouseup', onElementMouseUp);
                }
            } else { deselectAllElements(); exitConnectionMode(); }
        });

        window.addEventListener('mousemove', (e) => {
            if (!state.isResizing) return;
            let newWidth = state.initialWidth + (e.clientX - state.resizeStartX); let newHeight = state.initialHeight + (e.clientY - state.resizeStartY);
            newWidth = Math.max(50, Math.round(newWidth / state.gridSize) * state.gridSize); newHeight = Math.max(50, Math.round(newHeight / state.gridSize) * state.gridSize);
            if (state.resizingElement.dataset.type === 'circle') { const maxDim = Math.max(newWidth, newHeight); newWidth = maxDim; newHeight = maxDim; }
            state.resizingElement.style.width = `${newWidth}px`; state.resizingElement.style.height = `${newHeight}px`;
            updateElementConnections(state.resizingElement);
        });

        window.addEventListener('mouseup', () => { if (state.isResizing) { state.isResizing = false; document.body.style.cursor = 'default'; saveStateToHistory(); } });

        function selectNode(nodeElement) { nodeElement.classList.add('selected'); state.selectedNodes.add(nodeElement); updateToolbarState(); }
        function deselectNode(nodeElement) { nodeElement.classList.remove('selected'); state.selectedNodes.delete(nodeElement); updateToolbarState(); }
        function selectLine(lineElement) {
            deselectAllElements(); lineElement.classList.add('selected');
            if (lineElement.dataset.lineRoute === 'orthogonal') { lineElement.querySelectorAll('.line-segment').forEach(segment => segment.classList.add('selected')); }
            state.selectedLine = lineElement; updateToolbarState();
        }
        function deselectLine() {
            if (state.selectedLine) {
                state.selectedLine.classList.remove('selected');
                state.selectedLine.querySelectorAll('.line-segment').forEach(segment => segment.classList.remove('selected'));
                state.selectedLine = null;
            }
        }
        function deselectAllElements() {
            state.selectedNodes.forEach(node => node.classList.remove('selected')); state.selectedNodes.clear(); deselectLine();
            if (state.firstNodeForConnection) { state.firstNodeForConnection.classList.remove('line-selected'); state.firstNodeForConnection = null; }
            updateToolbarState();
        }
        
        function exitConnectionMode() { state.isConnectingMode = false; connectNodesBtn.classList.remove('active'); if (state.firstNodeForConnection) { state.firstNodeForConnection.classList.remove('line-selected'); state.firstNodeForConnection = null; } }
        connectNodesBtn.addEventListener('click', () => { state.isConnectingMode = !state.isConnectingMode; connectNodesBtn.classList.toggle('active', state.isConnectingMode); if (state.isConnectingMode) deselectAllElements(); else exitConnectionMode(); });
        
        function handleNodeConnectionClick(node) {
            if (!state.firstNodeForConnection) { state.firstNodeForConnection = node; node.classList.add('line-selected');
            } else if (state.firstNodeForConnection !== node) {
                const routeOption = lineStyleSelect.value;
                const style = (routeOption === 'solid' || routeOption === 'dotted') ? routeOption : 'solid';
                const lineRoute = (routeOption === 'orthogonal') ? 'orthogonal' : 'straight';
                createConnection(state.firstNodeForConnection, node, style, lineRoute);
                state.firstNodeForConnection.classList.remove('line-selected');
                state.firstNodeForConnection = null; saveStateToHistory();
            }
        }

        function createConnection(startNode, endNode, style, lineRoute) {
            const exists = state.connections.some(c => (c.startNodeId === startNode.id && c.endNodeId === endNode.id) || (c.startNodeId === endNode.id && c.endNodeId === startNode.id));
            if (exists) return; createConnectionDOM(generateUniqueId('line'), startNode, endNode, style, lineRoute);
        }

        function createConnectionDOM(id, startNode, endNode, style, lineRoute) {
            const lineDiv = document.createElement('div');
            lineDiv.id = id; lineDiv.dataset.style = style; lineDiv.dataset.lineRoute = lineRoute;
            lineDiv.className = `connection-line ${lineRoute}`; if (lineRoute === 'straight') lineDiv.classList.add(style);
            workflowCanvas.prepend(lineDiv);
            if (lineRoute === 'orthogonal') {
                const segment1 = document.createElement('div'); segment1.className = `line-segment segment-1 ${style}`;
                const segment2 = document.createElement('div'); segment2.className = `line-segment segment-2 ${style}`;
                lineDiv.append(segment1, segment2);
            }
            const conn = { id, startNodeId: startNode.id, endNodeId: endNode.id, lineElement: lineDiv, style, lineRoute };
            state.connections.push(conn); updateConnectionPosition(conn);
            lineDiv.addEventListener('mousedown', (e) => { e.stopPropagation(); selectLine(lineDiv); });
        }

        function updateElementConnections(element) { state.connections.forEach(conn => { if (conn.startNodeId === element.id || conn.endNodeId === element.id) updateConnectionPosition(conn); }); }
        
        function updateConnectionPosition(conn) {
            const startNode = document.getElementById(conn.startNodeId); const endNode = document.getElementById(conn.endNodeId); if (!startNode || !endNode) return;
            const startCenter = getElementCenter(startNode); const endCenter = getElementCenter(endNode);
            if (conn.lineRoute === 'orthogonal') {
                conn.lineElement.style.cssText = 'left: 0px; top: 0px; transform: none; width: 0; height: 0;';
                let segment1 = conn.lineElement.querySelector('.segment-1'); let segment2 = conn.lineElement.querySelector('.segment-2');
                if (!segment1) {
                    conn.lineElement.innerHTML = ''; segment1 = document.createElement('div'); segment1.className = `line-segment segment-1 ${conn.style}`;
                    segment2 = document.createElement('div'); segment2.className = `line-segment segment-2 ${conn.style}`; conn.lineElement.append(segment1, segment2);
                }
                const lineThickness = conn.lineElement.classList.contains('selected') ? 3 : 2; const halfThickness = lineThickness / 2;
                let midX = startCenter.x; let midY = endCenter.y;
                segment1.style.cssText = `left:${midX-halfThickness}px; top:${Math.min(startCenter.y, midY)}px; width:${lineThickness}px; height:${Math.abs(startCenter.y-midY)}px;`;
                segment2.style.cssText = `left:${Math.min(midX, endCenter.x)}px; top:${midY-halfThickness}px; width:${Math.abs(midX-endCenter.x)}px; height:${lineThickness}px;`;
            } else {
                const dx = endCenter.x - startCenter.x; const dy = endCenter.y - startCenter.y; const distance = Math.hypot(dx, dy); const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                if (conn.lineElement.querySelector('.line-segment')) conn.lineElement.innerHTML = '';
                conn.lineElement.style.cssText = `width:${distance}px; left:${startCenter.x}px; top:${startCenter.y}px; transform:rotate(${angle}deg); height:0;`;
            }
        }
        
        function addTextEditingListeners(textElement) {
            textElement.addEventListener('focus', () => updateToolbarState()); textElement.addEventListener('blur', () => { saveStateToHistory(); updateToolbarState(); });
            textElement.addEventListener('keyup', () => updateToolbarState()); textElement.addEventListener('mouseup', () => updateToolbarState());
            textElement.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); textElement.blur(); } });
        }
        function applyTextFormat(command) {
            document.execCommand(command, false, null); updateToolbarState();
            const activeNode = state.selectedNodes.values().next().value;
            if (activeNode) getTextElement(activeNode)?.focus();
        }
        function updateToolbarState() {
            const nodesSelectedCount = state.selectedNodes.size;
            const isLineSelected = !!state.selectedLine;
            const singleNodeSelected = nodesSelectedCount === 1;
            removeNodeBtn.disabled = nodesSelectedCount === 0 && !isLineSelected;
            lineStyleSelect.disabled = !isLineSelected;
            if (isLineSelected) { lineStyleSelect.value = state.selectedLine.dataset.lineRoute === 'orthogonal' ? 'orthogonal' : state.selectedLine.dataset.style; }
            textFormattingToolbar.classList.toggle('disabled', !singleNodeSelected);
            fontSizeInput.disabled = !singleNodeSelected;
            nodeColorInput.disabled = nodesSelectedCount === 0;
            document.querySelectorAll('#text-formatting-toolbar .text-format-button').forEach(b => b.classList.remove('active'));
            if(singleNodeSelected) {
                const node = state.selectedNodes.values().next().value;
                const textEl = getTextElement(node);
                fontSizeInput.value = parseInt(window.getComputedStyle(textEl).fontSize, 10);
                const colorTarget = node.dataset.type === 'diamond' ? node.querySelector('.rhombus-shape') : node;
                nodeColorInput.value = rgbToHex(window.getComputedStyle(colorTarget).backgroundColor);
                if (document.queryCommandState('bold')) document.querySelector('[data-command="bold"]').classList.add('active');
                if (document.queryCommandState('italic')) document.querySelector('[data-command="italic"]').classList.add('active');
                if (document.queryCommandState('underline')) document.querySelector('[data-command="underline"]').classList.add('active');
            } else {
                fontSizeInput.value = 14;
            }
        }
        
        document.querySelectorAll('#text-formatting-toolbar .text-format-button').forEach(button => { button.addEventListener('mousedown', (e) => { e.preventDefault(); applyTextFormat(button.dataset.command); }); });
        fontSizeInput.addEventListener('input', () => { if (state.selectedNodes.size === 1) { const textElement = getTextElement(state.selectedNodes.values().next().value); if (textElement) textElement.style.fontSize = `${fontSizeInput.value}px`; } });
        fontSizeInput.addEventListener('change', () => saveStateToHistory());

        nodeColorInput.addEventListener('input', () => {
            const newColor = nodeColorInput.value;
            state.selectedNodes.forEach(node => {
                const targetElement = node.dataset.type === 'diamond' ? node.querySelector('.rhombus-shape') : node;
                if(targetElement) targetElement.style.backgroundColor = newColor;
            });
        });
        nodeColorInput.addEventListener('change', () => { saveStateToHistory(); });

        lineStyleSelect.addEventListener('change', () => {
            if (state.selectedLine) {
                const conn = state.connections.find(c => c.id === state.selectedLine.id);
                if (conn) {
                    const newRoute = lineStyleSelect.value;
                    conn.lineRoute = (newRoute === 'orthogonal') ? 'orthogonal' : 'straight';
                    conn.style = (newRoute === 'dotted') ? 'dotted' : 'solid';
                    state.selectedLine.className = `connection-line ${conn.lineRoute} selected`;
                    if (conn.lineRoute === 'straight') state.selectedLine.classList.add(conn.style);
                    state.selectedLine.dataset.lineRoute = conn.lineRoute; state.selectedLine.dataset.style = conn.style;
                    updateConnectionPosition(conn); saveStateToHistory();
                }
            }
        });

        gridSizeInput.addEventListener('change', () => {
            const newGridSize = parseInt(gridSizeInput.value, 10);
            if (!isNaN(newGridSize) && newGridSize >= 5) {
                state.gridSize = newGridSize; workflowCanvas.style.backgroundSize = `${state.gridSize}px ${state.gridSize}px`;
                document.querySelectorAll('.workflow-node, .text-box').forEach(node => {
                    node.style.left = `${Math.round(node.offsetLeft / state.gridSize) * state.gridSize}px`;
                    node.style.top = `${Math.round(node.offsetTop / state.gridSize) * state.gridSize}px`;
                    updateElementConnections(node);
                });
                saveStateToHistory();
            } else { gridSizeInput.value = state.gridSize; }
        });

        async function getDiagramAsCanvas() {
            deselectAllElements(); exitConnectionMode(); const padding = 50; let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
            const nodes = document.querySelectorAll('.workflow-node, .text-box');
            if (nodes.length === 0) { alert("Canvas is empty."); return null; }
            nodes.forEach(node => { minX = Math.min(minX, node.offsetLeft); minY = Math.min(minY, node.offsetTop); maxX = Math.max(maxX, node.offsetLeft + node.offsetWidth); maxY = Math.max(maxY, node.offsetTop + node.offsetHeight); });
            const originalBg = workflowCanvas.style.backgroundImage; workflowCanvas.style.backgroundImage = 'none';
            const canvas = await html2canvas(workflowCanvas, { backgroundColor: '#f9f9f9', scale: 2, useCORS: true, x: minX - padding, y: minY - padding, width: (maxX - minX) + (padding * 2), height: (maxY - minY) + (padding * 2), });
            workflowCanvas.style.backgroundImage = originalBg; return canvas;
        }

        document.getElementById('exportPdfBtn').addEventListener('click', async () => {
            const diagramCanvas = await getDiagramAsCanvas(); if (!diagramCanvas) return;
            const diagramDataUrl = diagramCanvas.toDataURL('image/png'); const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({ orientation: diagramCanvas.width > diagramCanvas.height ? 'l' : 'p', unit: 'px', format: [diagramCanvas.width, diagramCanvas.height] });
            const addLogoAndSave = (logoDataUrl) => {
                if (logoDataUrl) { pdf.addImage(logoDataUrl, 'PNG', 15, 15, 50, 25); }
                pdf.addImage(diagramDataUrl, 'PNG', 0, 0, diagramCanvas.width, diagramCanvas.height); pdf.save('workflow-diagram.pdf');
            };
            const logoUrl = 'YOUR_LOGO_URL_HERE';
            fetch(logoUrl).then(response => response.blob()).then(blob => new Promise((resolve, reject) => {
                const reader = new FileReader(); reader.onloadend = () => resolve(reader.result); reader.onerror = reject; reader.readAsDataURL(blob);
            })).then(dataUrl => addLogoAndSave(dataUrl)).catch(error => { console.error("Logo not found, exporting PDF without it.", error); addLogoAndSave(null); });
        });

        document.getElementById('printBtn').addEventListener('click', async () => { const canvas = await getDiagramAsCanvas(); if (!canvas) return; const dataUrl = canvas.toDataURL('image/png'); const printWindow = window.open('', '_blank'); printWindow.document.write(`<html><head><title>Print Diagram</title><style>body{margin:0}img{width:100%;height:auto;}@page{size:auto;margin:20mm}</style></head><body><img src="${dataUrl}"></body></html>`); printWindow.document.close(); printWindow.onload = () => { printWindow.focus(); printWindow.print(); printWindow.close(); }; });
        document.getElementById('clearCanvasBtn').addEventListener('click', () => { if(confirm('Clear canvas?')) { initializeApp(true); } });
        document.getElementById('saveBtn').addEventListener('click', () => { saveStateToHistory(); localStorage.setItem('workflowData', JSON.stringify(state.history[state.historyIndex])); alert('Workflow saved!'); });
        document.getElementById('loadBtn').addEventListener('click', () => { if(confirm('Loading will clear the canvas. Continue?')) { const data = localStorage.getItem('workflowData'); if(data) { loadWorkflowDataIntoCanvas(JSON.parse(data)); } else { alert('No saved data found.');}} });
        document.getElementById('exportJsonBtn').addEventListener('click', () => { saveStateToHistory(); const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(state.history[state.historyIndex], null, 2)); const dl = document.createElement('a'); dl.href = dataStr; dl.download = "workflow.json"; dl.click(); });
        
        document.getElementById('importBtn').addEventListener('click', () => {
            const input = document.createElement('input'); input.type = 'file'; input.accept = '.json';
            input.onchange = e => {
                const file = e.target.files[0];
                if(file && confirm('Importing will clear canvas. Continue?')) {
                    const reader = new FileReader();
                    reader.onload = res => {
                        try {
                            let fileContent = res.target.result;
                            const startIndex = fileContent.indexOf('{');
                            if (startIndex === -1) throw new Error("No JSON object found.");
                            let openBraces = 0;
                            let endIndex = -1;
                            for (let i = startIndex; i < fileContent.length; i++) {
                                if (fileContent[i] === '{') openBraces++;
                                else if (fileContent[i] === '}') openBraces--;
                                if (openBraces === 0) {
                                    endIndex = i;
                                    break;
                                }
                            }
                            if (endIndex === -1) throw new Error("JSON object is incomplete or malformed.");
                            const jsonObjectStr = fileContent.substring(startIndex, endIndex + 1);
                            loadWorkflowDataIntoCanvas(JSON.parse(jsonObjectStr));
                        } catch (err) {
                            alert('Invalid JSON. Error: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        });

        function loadWorkflowDataIntoCanvas(workflowData, saveToHistoryFlag = true) {
            workflowCanvas.innerHTML = ''; state.connections = []; deselectAllElements(); exitConnectionMode();
            if (workflowData?.nodes) { workflowData.nodes.forEach(nodeData => createNodeOnCanvas(nodeData.type, 0, 0, nodeData)); }
            if (workflowData?.connections) { workflowData.connections.forEach(connData => {
                const startNode = document.getElementById(connData.startNodeId); const endNode = document.getElementById(connData.endNodeId);
                if (startNode && endNode) createConnectionDOM(connData.id, startNode, endNode, connData.style || 'solid', connData.lineRoute || 'straight');
            }); }
            if (saveToHistoryFlag) saveStateToHistory(); updateToolbarState();
        }

        window.addEventListener('keydown', (e) => {
            const isEditingText = document.activeElement && (document.activeElement.contentEditable === 'true' || ['INPUT', 'SELECT'].includes(document.activeElement.tagName));
            if (isEditingText && e.key !== 'Escape') return;
            const isCtrlCmd = e.ctrlKey || e.metaKey;
            if ((e.key === 'Delete' || e.key === 'Backspace')) deleteSelectedElement();
            else if (isCtrlCmd && e.key.toLowerCase() === 'c') copySelectedElement();
            else if (isCtrlCmd && e.key.toLowerCase() === 'v') pasteElement(e);
            else if (isCtrlCmd && e.key.toLowerCase() === 'z') { e.preventDefault(); isCtrlCmd && e.shiftKey ? redo() : undo(); }
            else if (isCtrlCmd && e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); }
        });
        
        function deleteSelectedElement() {
            if (state.selectedNodes.size > 0) {
                state.selectedNodes.forEach(node => {
                    node.remove();
                    state.connections = state.connections.filter(c => {
                        if (c.startNodeId === node.id || c.endNodeId === node.id) { c.lineElement.remove(); return false; } return true;
                    });
                });
                state.selectedNodes.clear();
            } else if (state.selectedLine) {
                state.selectedLine.remove();
                state.connections = state.connections.filter(c => c.id !== state.selectedLine.id);
                state.selectedLine = null;
            }
            deselectAllElements(); saveStateToHistory();
        }
        removeNodeBtn.addEventListener('click', deleteSelectedElement);
        
        function copySelectedElement() {
            if (state.selectedNodes.size > 0) {
                const nodeToCopy = state.selectedNodes.values().next().value;
                const textElement = getTextElement(nodeToCopy);
                state.clipboard = { type: nodeToCopy.dataset.type, text: textElement?.innerHTML, width: nodeToCopy.style.width, height: nodeToCopy.style.height, fontSize: textElement?.style.fontSize };
            } else { state.clipboard = null; }
        }
        function pasteElement(e) {
            if (!state.clipboard) return;
            const canvasRect = workflowCanvas.getBoundingClientRect();
            let pasteX = e.clientX - canvasRect.left + workflowCanvas.scrollLeft + 20;
            let pasteY = e.clientY - canvasRect.top + workflowCanvas.scrollTop + 20;
            const nodeData = { ...state.clipboard, id: generateUniqueId(state.clipboard.type), left: `${pasteX}px`, top: `${pasteY}px` };
            createNodeOnCanvas(state.clipboard.type, 0, 0, nodeData);
        }
        function undo() { if(state.historyIndex > 0) { state.historyIndex--; loadStateFromHistory(state.historyIndex); } }
        function redo() { if(state.historyIndex < state.history.length - 1) { state.historyIndex++; loadStateFromHistory(state.historyIndex); } }

        function initializeApp(forceNew = false) {
            const savedData = localStorage.getItem('workflowData');
            if (savedData && !forceNew) { loadWorkflowDataIntoCanvas(JSON.parse(savedData));
            } else {
                workflowCanvas.innerHTML = ''; state.connections = []; deselectAllElements(); exitConnectionMode();
                const titleData = { id: 'title-box-1', type: 'text-box', text: 'Diagram Flow Chart', left: 'calc(50% - 175px)', top: '40px', width: '350px', height: 'auto', fontSize: '28px' };
                const titleNode = createNodeOnCanvas('text-box', 0, 0, titleData);
                const textEl = getTextElement(titleNode);
                if (textEl) { textEl.style.fontWeight = 'bold'; textEl.style.textAlign = 'center'; }
                titleNode.style.cssText += 'align-items:center; justify-content:center; border-style:dotted;';
                saveStateToHistory();
            }
            workflowCanvas.style.backgroundSize = `${state.gridSize}px ${state.gridSize}px`;
            updateToolbarState();
        }
        initializeApp();
    </script>
</body>
</html>
